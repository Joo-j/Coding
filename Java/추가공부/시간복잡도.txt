1) 시간 복잡도

시간 복잡도란 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것으로 기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산입니다.

?

Ex) 기본 연산 - 사칙연산, 대소비교, 변수에 값 대입

       기본 연산 x - 배열 정렬, 두 문자열이 같은지 확인, 소인수 분해

?

여기서 유의할 점은 시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행시간이 더 빠르게 

증가한다는 의미입니다. 

즉, 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아니라는 것입니다.

입력의 크기가 작을 때에는 시간 복잡도가 높은 알고리즘이 더 빠르게 작동할 수 있습니다.

다시한번 강조하지만 시간복잡도는 입력의 크기가 충분히 클 때를 기준으로 생각해야합니다.

그렇기 때문에 시간복잡도가 완벽한 속도의 기준이라고는 할 수 없습니다.

?

2) 시간복잡도의 분할 상환 분석

이 책에서 깊게 다루고 있지는 않으므로 아주 간단한 정도로만 정리하겠습니다.

시간복잡도의 분할 상환 분석은 하나의 큰 작업이 N개의 작은 작업들을 순서대로 수행하는 것으로 이루어져 있다고 할 때, 각 작업에 걸리는 시간을 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우 적용 할 수 있습니다. 이 때 각 작업에 걸리는 평균 시간은 전체 시간을 작업의 개수로 나눈 것과 같다고 할 수 있습니다.

분할 상환 분석을 이용하면 일반적으로는 시간이 오래 걸려 실행하지 못할 것이라고 여겼던 작업이 시간 안에 돌아가는 것을 이해 할 수 있게 됩니다.

?

3) 수행시간 어림짐직하기 - 주먹구구식 방법

프로그램을 작성하기 전에 입력의 최대크기와 알고리즘의 시간 복잡도를 보고 수행시간을 어림 짐작할 수 있어야 합니다. 정확히는 알 수 없지만 많은 경우에 시간 복잡도와 입력 크기만 알고 있더라도 어떤 알고리즘이 시간안에 작동 할 수 있을지 대략적으로 짐작하는 것이 가능합니다.

입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면 시간 제한을 초과할 가능성이 있다.

이 기준을 활용하면 아주 대략적으로 알고리즘의 시간 기준을 판단해 볼 수 있습니다.

Ex) 입력 최대크기 N이 10000이고 시간제한이 1초라면 

>> O(N^3)은 10000^3 = 10^12 이므로 시간을 초과할 것이다.

>> O(N^2)는 10000^2 = 10^8 이므로 확정지을 수 없다. 시도해볼만 하다.

>> O(NlogN)은 10000*4 = 10^4 이므로 높은 확률도 시간을 초과하지 않을 것이다.

?

라고 판단해 볼 수 있는 휴리스틱한 근거가 될 수 있습니다.

?

4) 계산 복잡도 이론에서의 P,NP 문제

?P문제는 다항 시간 알고리즘이 존재하는 문제를 의미

NP문제는 단이 주어졌을 때 이것이 정답인지를 다항시간 내에 확인할수 있는 문제를 의미
[출처] [알.문.전] 1.4 시간 복잡도|작성자 토적