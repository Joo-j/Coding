다이나믹 프로그래밍은 프로그래밍 대회를 준비하시는 분에게는 절대 피할 수 없는 숙명입니다. 다이나믹 프로그래밍 문제는 종류가 굉장히 많으며 컴퓨터적인 사고력을 물어보기에 적합하다는 점에서 자주 출제되기 때문입니다. 다이나믹 프로그래밍이란 하나의 문제는 단 한 번만 풀도록 하는 알고리즘 입니다. 한 번 푼 것을 여러 번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이기도 합니다.

일반적으로 상당수 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있습니다. (다만 분할 정복 기법은 정렬과 같은 몇몇 요소에 대해서는 동일한 문제를 다시 풀게 되는 단점이 없습니다. 그 예시로 퀵 정렬이나 병합 정렬은 매우 빠릅니다.) 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있습니다. 피보나치 수열은 특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합을 구해야 합니다.



1.
다이나믹 프로그래밍은 재귀적 기법 등을 통하여 스스로 반복적으로 문제를 해결하는 해결 기법을 통칭하고요.

2.
대체로 2가지 방법이 제시되는데요
첫째가 함수의 재귀적 호출이 있고
둘째는 데이터의 메모라이즈(배열/매트릭스화) 방법이 있습니다.

가장 유명한 피보나치 수열을 예로 들면
재귀함수적 접근은 F(n) = F(n - 1) + F(n - 2) 이런 식으로 만들고 F(10) 이렇게 넣어버리지요.
이 방법은 10에서 순차적으로 쭉 1까지 스스로 내려갑니다.

*데이터 메모라이즈 방법은 거꾸로 1부터 출발해서 값을 계속 Array 쌓습니다.
F(1) = 1
F(2) = 2
F(3) = F(2) + F(1) 이때 F는 배열입니다. 배열에 값을 저장하면서 점차 배열이 불어나는 형식이 되겠지요.

3. 피보나치를 위의 case로 두가지로 만들어보면 이렇게 되겠네요.
둘다 피보나치를 구현하지만 *topdown은 재귀를 *bottomup은 배열을 썼습니다.
피보나치는 원래가 재귀 함수로 정의되는 놈인지라 재귀가 더 낫다고 생각하실 수 있겠지만,
특정 문제는 배열에 저장해가면서 계산해야 합니다. (예를 들면 shortest-path 나 sort 알고리즘 들이죠)

int topdown(int n)

{       

        if(n <= 2)

                return n;

        return topdown(n - 1) + topdown(n - 2);

}



int bottomup(int n)

{

        int array[100]; // 이건 이렇게 지정하면 안되지만 간단히 하느라 ;;

        int k = 0;



        while(k++ <= n) {

                if(k <= 2)

                        array[k] = k;

                else

                        array[k] = array[k-1] + array[k-2];

        }

        return array[n];

}