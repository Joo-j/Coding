힙 정렬은 병합정렬, 퀵정렬 만큼이나 빠른 정렬 알고리즘이다
힙정렬은 힙 트리 구조를 이용하는 정렬 방법이다
힙을 이용해 정렬
이진트리 : 컴퓨터가 데이터를 표현하고자 할때 데이터를 두개씩 이어붙이는 구조 (노드)
부모에서 (최대 두가지) 자식으로 뻗어나가는 형태
트리의 최상단을 루트, 최하단을 리프노드라고 함
트리라는 것은 말 그대로 가지를 뻗어나가는 것처럼 데이터가 서로 연결되어있다.
트리는 그 종류가 다양함
완전 이진 트리: 데이터가 왼쪽 오른쪽 차근차근 들어가는 구조의 이진 트리, 이진트리의 노드가 중간에 비어있거나 하지 않아서 아주 빽백하게 차있어서 완전이진트리라고 함
1           1             1                   1
    ->   2     ->    2     3   ->       2     3
                                         4        

힙: 최솟값이나 혹은 최댓값을 아주 빠르게 찾아내기 위해서 완전이진트리를 이용하는 하나의 트리구조
최대힙: 부모 노드가 자식 노드보다 큰 힙, 즉 더 큰 값이 부모가 된다 
최소힙: 
힙정렬을 하기위해서는 기본적으로 힙구조를 만들어줘야함

힙구조  
자식노드보다 값이 부모노드의 값이 커야함

       7                                    11
   5       3                           9          8
                                    7        4


힙 구조가 형성이 되어있지 않다면 그 부모 노드와 자식 노드 중 더 큰값을 바꿔나가면서 힙 구조를 만든다 - 힙 생성 알고리즘(heapify)
힙 생성 알고리즘의 시간복잡도 - O(Log N) : 완전이진트리 구조를 사용하기 때문에, 매우 빠름, 백만이라도 해도 20번만 heapify해주면됨, 실제로는 N/2&logN -> 결국 N(설명필요)
실제 힙구조는 전체개수에서 1/2개만 heapify해주면됨 9면 4번, 5면 2번

 
힙 구조는 밑에서 위로 올라가면서 힙구조를 만들어나가도 되고 위에서 아래로 내려가면서 만들어도 됨  (상향식, 하향식)

힙구조가 만들어졌다면 힙정렬의 과정은 가장 큰값을 찾아서 트리의 가장 마지막 부분의 값과 바꾸고 그 가장 큰값을 제외한뒤 위에서부터 아래로 다시 힙구조를 만들어 나가게 되면 또 다시 힙구조가 만들어지게되고 이 과정을 반복하면 결국 아래쪽부터 큰수가 차례대로 정렬이 되어나간다.
힙을 만들때의 heapify의 시간복잡도는 LogN
전체 원소의 개수만큼 반복해서 수행하면 정렬이 이루어지기 때문에 N*LogN 전체 시간복잡도가 되는것이다
즉 힙정렬의 전체 시간 복잡도는 O(N*LogN)


static int heap[];

static void heapify(int heap[], n){
//전체 트리 구조를 힙 구조로 만들어줌
for(int i = 1; i<n; i++){ 
int c= i; //첫번째 노드부터 시작, 두번째 노드, 세번째노드 차례대로 heapify
do{
int root = (c-1) /2; // 자기자신의 부모 인덱스
if(heap[root] < heap[c]){ //부모의 값보다 자식의 값이 더 크다면 교환
int temp = heap[root];
heap[root] =heap[c];
heap[c] = temp;
}
c= root; // 다시 부모의 인덱스로 가서 heapify를 수행
}while(c!=0)
}
sort(heap, n);
}

static void sort(int heap[], int n){
//크기를 줄여가며 반복적으로 힙을 구성
for(int i = n-1; i>=0; i++){ // 
int temp = heap[0]; //가장 큰값(맨앞의값을) 가장 마지막 값과 바꿔준다
heap[0] = heap[i];
heap[i] = temp;
int root = 0;
int c = 1;
do{
c =2 * root +1 ; // 루트의 자식 인덱스
if(heap[c]<heap[c+1] && c<i-1){  //자식 중에 더 큰 값을 찾기                                   
c++; // 더 큰 값의 인덱스로, //(3 7)이면 7이 더 크니까 7의 인덱스로
}
if(heap[root]<heap[c] && c<i){ //(두 자식중에 큰값을 찾아 비교해) 루트보다 자식이 더 크다면 교환
int temp = heap[root]; 
heap[root] = heap[c];
heap[c] = temp;
}
root = c; // 다시 c를 루트로 이동시켜서 위로 올라가면서 계속해서 재귀적으로 힙구조를 만들어준다
}while(c<i);
}

public static void main(String[] args){

Scanner sc = new Scanner(System.in)
int n = sc.nextInt();
for(int i=0; i<n; i++){
heap[i] = sc.nextInt();
}

heapify(heap, n);

for(int i=0; i<n; i++){
System.out.print(heap[i]);
}
}
}



추가적인 배열이 필요하지 않다는 점에서 메모리 측면에서 몹시 효율적이고 항상 O(N*LogN)을 보장할 수 있다는 점에서 몹시 강력한 정렬 알고리즘이다
이론적으로는 퀵정렬, 병합정렬보다 더 우위에 있다고 할 수 있다