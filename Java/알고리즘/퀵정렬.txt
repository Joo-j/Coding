퀵정렬은 N*log(n) 으로 굉장히 빠른 속도의 정렬법
log(n)은 거의 상수라고 할수 있을정도로 작은 값 
분할정복 알고리즘 이라고 부름
왼쪽 오른쪽, 집합이 나누어지기 때문에 빠른것
선택정렬은 
n^10 = 10 * 10 =100
퀵정렬은 
12345  = 5 * 5
678910 = 5 * 5
= 25 + 25 = 50

잘개 쪼갠다음에 그것들을 각자 정렬하고 나중에 합치게 되면은 결과적으로 훨씬 적은 숫자만큼 연산을 하게된다
분할정복이 무서운 이유
반으로 쪼개는 과정은 2씩 계속해서 나눈다는 점에서 log(N)이라고 할 수 있다.
N(데이터의 개수) * LogN(반씩쪼개들어가는것)
퀵정렬을 하면서 피벗보다 왼쪽에 있게 되는 집합(값)들은 피벗보다 작고 피벗보다 오른쪽에 있는 집합(값)들은 피벗보다 크다
이미 정렬이 되어있거나 거의 다 정렬이 되어있을때 쓰면 매우 비효율적임 -> 최악의 시간복잡도 N^2
항상 어떤 정렬이 빠르다 이런식은 아무의미가없다 상황마다 다르다



1.피벗을 정한다. (첫번째 인덱스 값)
2.피벗을 제외한 나머지 값들중에서 
a:맨 왼쪽에서 오른쪽 방향으로(->) 피벗보다 큰값이 있는지 인덱스를 탐색하고 
b:맨 오른쪽에서 왼쪽 방향으로(<-) 피벗보다 작은값이 있는지 인덱스를 탐색하여
찾은 두개의 값들을 서로 교환해준다
3. 탐색하다가 a의 값이 b의 값보다 더 낮은 인덱스, 즉 더 왼쪽에 위치할 경우 (엇갈림)
그 b의 값을 피벗과 교환한 후 피벗이었던 값을 고정 시켜주고 정렬에서 배제한다.
(피벗보다 작거나 큰 값이 없다면 탐색 인덱스가 끝부분까지 찾았는데도 없다는 얘기이므로 인덱스가 맨 앞 또는 맨 뒤 값 끝에 가있고, 이는 엇갈린 것임으로 b와 피벗을 교환하여 확정시켜줘야하지만 b값이 없으므로 피벗 자기 자신과 교환을해 그 값을 고정 시켜준다.)
4. 확정된 값을 기준으로 왼쪽집합과 오른쪽 집합이 생기는데 이들을 또 다시 정렬을 해준다.
(왼쪽 집합과 오른쪽 집합 또한 첫번째 인덱스 값을 피벗으로 설정시켜 전과같이 정렬해준다.)
5.이를 반복한다. 
 


예)
3 7 8 1 5 9 6 10 2 4




ㅁ시작ㅁ
(3) 7 8 1 5 9 6 10 2 4 
a-7 <->  b-2

-> (3) 2 8 1 5 9 6 10 7 4
a-8 <-> b-1

-> (3) 2 1 8 5 9 6 10 7 4
a-8 b-1,  b가 a보다 더 왼쪽에 있으므로 b와 피벗값 교환 후 고정

-> (1) 2  ③  8 5 9 6 10 7 4         
왼쪽과 오른쪽 집합 나눠짐           




1 2 ③ 8 5 9 6 10 7 4                      




ㅁ첫번째 왼쪽 집합 시작ㅁ
(1) 2
a-2 b-1, b가 a보다 더 왼쪽에 있고 피벗값과 같으므로 b와 피벗을 교환, 즉 자기자신과 교환 후 고정

->① 2
오른쪽 집합 생김




① 2 ③ 8 5 9 6 10 7 4  





ㅁ두번째 오른쪽 집합 시작ㅁ
(2)
a- b-, 피벗보다 작은값, 큰값이 모두 없고 a의 인덱스가 2의 오른쪽, b의 인덱스가 2의 왼쪽으로 가있어 엇갈린것으로 판단. b와 피벗값을 바꿔준다 하지만 b의 값이 정해지지 않았기 때문에 자동으로 b는 피벗값으로 대체되어 자기자신과 교환하고 고정한다.

->②
두번째 오른쪽 집합 고정





① ② ③ 8 5 9 6 10 7 4      




ㅁ첫번째 오른쪽 집합 시작ㅁ
(8) 5 9 6 10 7 4 

-> (8) 5 9 6 10 7 4 
a-9 <-> b-4

-> (8) 5 4 6 10 7 9 
a-10 <-> b-7
 
-> (8) 5 4 6 7 10 9 
a-10 b-7 , b가 a보다 더 왼쪽에 있으므로 b와 피벗값 교환 후 고정

-> 7 5 4 6 ⑧ 10 9 
왼쪽과 오른쪽 집합 나눠짐




① ② ③ 7 5 4 6 ⑧ 10 9    





ㅁ두번째 왼쪽 집합 시작ㅁ
(7) 5 4 6
a- b-6,  피벗보다 큰 값이 없어 a의 인덱스가 맨 마지막으로 가있고 b의 인덱스는 값이 6이있는 인덱스에 위치하기 때문에 서로 엇갈린 것으로 판단하여 b와 피벗값을 교환한후 고정시켜준다
 
->6 5 4 ⑦
왼쪽 집합 생김




① ② ③ 6 5 4 ⑦ ⑧ 10 9    




ㅁ세번째 왼쪽 집합 시작ㅁ
(6) 5 4
a-  b-4, 피벗보다 큰 값이 없어 a의 인덱스가 맨 마지막으로 가있고 b의 인덱스는 값이 4이있는 인덱스에 위치하기 때문에 서로 엇갈린 것으로 판단하여 b와 피벗값을 교환한후 고정시켜준다

-> 4 5 ⑥
왼쪽 집합 생김




① ② ③ 4 5 ⑥ ⑦ ⑧ 10 9   





ㅁ네번째 왼쪽 집합 시작ㅁ
(4) 5
a-5 b-. 피벗보다 작은 값이 없어 b의 인덱스가 맨 앞으로 가있고 a의 인덱스는 값이 5가있는 인덱스에 위치하기 때문에 서로 엇갈린 것으로 판단하여 b와 피벗값을 바꿔줘야하는데 b의 값이 정해지지 않았기 때문에 즉 자동으로 피벗의 값으로 선택되어 자기자신과 교환하게 된다

->④5
오른쪽 집합 생김




① ② ③ ④ 5 ⑥ ⑦ ⑧ 10 9   




ㅁ세번째 오른쪽 집합 시작ㅁ
(5)
a- b- 피벗보다 작은값, 큰값 모두 없어 a의 인덱스가 5의 오른쪽으로 가있고 b의 인덱스가 5의 앞으로 가있어 엇갈린것으로 판단하여 b와 피벗값을 바꿔준다 하지만 b의 값이 정해지지 않았기 때문에 자동으로 b는 피벗값으로 대체되어 자기자신과 교환하고 고정한다.

->⑤
두번째 오른쪽 집합 고정




① ② ③ ④ ⑤ ⑥ ⑦ ⑧ 10 9   



ㅁ두번째 오른쪽 집합 시작ㅁ
(10) 9
a- b-9 , 피벗보다 큰 값이 없어 a의 인덱스가 맨 마지막으로 가있고 b의 인덱스는 값이 4이있는 인덱스에 위치하기 때문에 서로 엇갈린 것으로 판단하여 b와 피벗값을 교환한후 고정시켜준다

->9 ⑩
왼쪽집합 생김



① ② ③ ④ ⑤ ⑥ ⑦ ⑧ 9 ⑩   





ㅁ다섯번째 왼쪽 집합 시작ㅁ
(9)
a- b- 피벗보다 작은값, 큰값 모두 없어 a의 인덱스가 5의 오른쪽으로 가있고 b의 인덱스가 5의 앞으로 가있어 엇갈린것으로 판단하여 b와 피벗값을 바꿔준다 하지만 b의 값이 정해지지 않았기 때문에 자동으로 b는 피벗값으로 대체되어 자기자신과 교환하고 고정한다.

->⑨
다섯번째 왼쪽집합 끝
끝





① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩









피벗을 첫번째 인덱스로 할때

package j;

import java.util.Scanner;

public class Main {
	
		static int data[];	

	static void quickSort(int data[], int start, int end){

		if(start >= end){ //원소가 1개인 경우
		return;
		}

		int key = start; //키는 가운데 인덱스 값(키=피벗)
		int i = start+1;
		int j = end;
		int temp;

		while(i<=j){ //엇갈릴 때 까지 반복
		while(data[i]<=data[key] && j < end){// 키 값보다 큰 값
		i++;
		}
		while(data[j]>=data[key] && j > start) {// 키 값보다 작은 값
		j--;
		}
		if(i>j){ //현재 엇갈린 상태면 키 값과 교체
		temp=data[j];
		data[j]=data[key];
		data[key]=temp;
		}else{ //엇갈리지 않았다면 두 값을 교체
		temp=data[j];
		data[j]=data[i];
		data[i]=temp;
		}}

		quickSort(data, start, j-1); //왼쪽 집합에서 다시 정렬 시작
		quickSort(data, j+1, end); //오른쪽 집합에서 다시 정렬 시작
		}

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		data = new int[n];
		for(int i=0;i<n; i++) {
			data[i]=sc.nextInt();
		}
		quickSort(data, 0 , data.length-1);
		for(int i=0; i<data.length; i++){
		System.out.print(data[i]);
		}
		}
	}






# include <stdio.h>
# define MAX_SIZE 9
# define SWAP(x, y, temp) ( (temp)=(x), (x)=(y), (y)=(temp) )

// 1. 피벗을 기준으로 2개의 부분 리스트로 나눈다.
// 2. 피벗보다 작은 값은 모두 왼쪽 부분 리스트로, 큰 값은 오른쪽 부분 리스트로 옮긴다.
/* 2개의 비균등 배열 list[left...pivot-1]와 list[pivot+1...right]의 합병 과정 */
/* (실제로 숫자들이 정렬되는 과정) */
int partition(int list[], int left, int right){
  int pivot, temp;
  int low, high;

  low = left;
  high = right + 1;
  pivot = list[left]; // 정렬할 리스트의 가장 왼쪽 데이터를 피벗으로 선택(임의의 값을 피벗으로 선택)

  /* low와 high가 교차할 때까지 반복(low<high) */
  do{
    /* list[low]가 피벗보다 작으면 계속 low를 증가 */
    do {
      low++; // low는 left+1 에서 시작
    } while (low<=right && list[low]<pivot);

    /* list[high]가 피벗보다 크면 계속 high를 감소 */
    do {
      high--; //high는 right 에서 시작
    } while (high>=left && list[high]>pivot);

    // 만약 low와 high가 교차하지 않았으면 list[low]를 list[high] 교환
    if(low<high){
      SWAP(list[low], list[high], temp);
    }
  } while (low<high);

  // low와 high가 교차했으면 반복문을 빠져나와 list[left]와 list[high]를 교환
  SWAP(list[left], list[high], temp);

  // 피벗의 위치인 high를 반환
  return high;
}

// 퀵 정렬
void quick_sort(int list[], int left, int right){

  /* 정렬할 범위가 2개 이상의 데이터이면(리스트의 크기가 0이나 1이 아니면) */
  if(left<right){
    // partition 함수를 호출하여 피벗을 기준으로 리스트를 비균등 분할 -분할(Divide)
    int q = partition(list, left, right); // q: 피벗의 위치

    // 피벗은 제외한 2개의 부분 리스트를 대상으로 순환 호출
    quick_sort(list, left, q-1); // (left ~ 피벗 바로 앞) 앞쪽 부분 리스트 정렬 -정복(Conquer)
    quick_sort(list, q+1, right); // (피벗 바로 뒤 ~ right) 뒤쪽 부분 리스트 정렬 -정복(Conquer)
  }

}

void main(){
  int i;
  int n = MAX_SIZE;
  int list[n] = {5, 3, 8, 4, 9, 1, 6, 2, 7};

  // 퀵 정렬 수행(left: 배열의 시작 = 0, right: 배열의 끝 = 8)
  quick_sort(list, 0, n-1);

  // 정렬 결과 출력
  for(i=0; i<n; i++){
    printf("%d\n", list[i]);
  }
}
https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html